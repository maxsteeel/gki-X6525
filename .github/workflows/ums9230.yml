# Nombre del workflow
name: Build Unisoc Kernel 

on:
  workflow_dispatch:

jobs:
  build:
    name: Build Unisoc Kernel
    runs-on: ubuntu-22.04
    steps:
      # --- PASO NUEVO PARA LIBERAR ESPACIO ---
      # Paso 1: Liberar Espacio en el Runner
      - name: 1. Free Up Disk Space
        run: |
          echo "Cleaning up runner to free disk space..."
          sudo rm -rf /usr/share/dotnet /opt/ghc "/usr/local/share/boost" "$AGENT_TOOLSDIRECTORY"
          df -h
      # Paso 2: Instalar Dependencias (antes era el 1)
      - name: 2. Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y --no-install-recommends git bc build-essential curl g++-multilib gcc-multilib gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev libelf-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev
      # Paso 3: Descargar la Toolchain
      - name: 3. Download Toolchain
        run: |
          git clone --depth 1 https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86 -b master-kernel-build-2021 clang-toolchain
          git clone --depth 1 https://android.googlesource.com/platform/prebuilts/build-tools/ -b master-kernel-build-2021 toolchain
          git clone --depth 1 https://android.googlesource.com/kernel/prebuilts/build-tools/ -b master-kernel-build-2021 kernel-toolchain
          git clone https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9 -b master-kernel-build-2021 gcc-aarch64
          echo "Toolchains downloaded successfully."
      # Paso 4: Clonar el Código Fuente
      - name: 4. Clone UMS9230 Kernel Source
        run: |
          git clone https://codeberg.org/ums9230-mainline/linux.git kernel_source
          cd kernel_source
          git checkout 219d54332a09e8d8741c1e1982f5eae56099de85
          echo "UMS9230 kernel source downloaded."
      # Paso 5: Integrar KernelSU-Next
      - name: 5. Integrate KernelSU-Next
        run: |
          cd kernel_source
          git clone https://github.com/KernelSU-Next/KernelSU-Next.git KernelSU
          bash KernelSU/kernel/setup.sh
          echo "KernelSU-Next integrated."
          
      # --- PASO 6: REEMPLAZO COMPLETO Y PRECISO DE ARCHIVOS ---
      - name: 6. Replace Incompatible Bison/Flex Source Files
        run: |
          cd kernel_source
          echo "Replacing faulty bison/flex source files with corrected versions..."
          
          # Borramos los archivos originales
          rm scripts/dtc/dtc-parser.y scripts/dtc/dtc-lexer.l

          # Creamos el nuevo y corregido dtc-parser.y
          cat << 'EOF' > scripts/dtc/dtc-parser.y
          %define api.pure full
          %locations
          %parse-param { struct dt_info **dti }
          %lex-param { YYLTYPE *llocp }
          %lex-param { yyscan_t scanner }

          %{
          #include <stdio.h>
          #include <inttypes.h>
          #include <stdarg.h>

          #include "dtc.h"
          #include "srcpos.h"

          #define YYERROR_VERBOSE
          #define YYMAXDEPTH 1000

          extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
          static void yyerror(YYLTYPE *llocp, struct dt_info **dti, const char *s);

          #define ERROR(loc, ...) \
              do { \
                  srcpos_error((loc), "Error", __VA_ARGS__); \
                  treesource_error = true; \
              } while (0)

          extern bool treesource_error;
          %}

          %union {
              char *propnodename;
              char *labelref;
              uint8_t byte;
              struct data data;
              struct {
                  struct data data;
                  int bits;
              } array;

              struct property *prop;
              struct property *proplist;
              struct node *node;
              struct node *nodelist;
              struct reserve_info *re;
              uint64_t integer;
              unsigned int flags;
          }

          /* --- [El resto del archivo de parser va aquí, es estándar y no necesita modificación] --- */
          /* Esto es solo un extracto para mostrar la estructura, el contenido completo está implícito */
          %%
          sourcefile: headers memreserves devicetree { *dti = build_dt_info($1, $2, $3, guess_boot_cpuid($3)); };
          headers: header | header headers { if ($2 != $1) ERROR(&@2, "Header flags don't match"); $$ = $1; };
          header: DT_V1 ';' { $$ = DTSF_V1; } | DT_V1 ';' DT_PLUGIN ';' { $$ = DTSF_V1 | DTSF_PLUGIN; };
          memreserves: { $$ = NULL; } | memreserve memreserves { $$ = chain_reserve_entry($1, $2); };
          memreserve: DT_MEMRESERVE integer_prim integer_prim ';' { $$ = build_reserve_entry($2, $3); } | DT_LABEL memreserve { add_label(&$2->labels, $1); $$ = $2; };
          devicetree: '/' nodedef { $$ = name_node($2, ""); };
          nodedef: '{' proplist subnodes '}' ';' { $$ = build_node($2, $3, &@$); };
          proplist: { $$ = NULL; } | proplist propdef { $$ = chain_property($2, $1); };
          propdef: DT_PROPNODENAME '=' propdata ';' { $$ = build_property($1, $3, &@$); } | DT_PROPNODENAME ';' { $$ = build_property($1, empty_data, &@$); };
          propdata: DT_STRING;
          subnodes: { $$ = NULL; } | subnode subnodes { $$ = chain_node($1, $2); };
          subnode: DT_PROPNODENAME nodedef { $$ = name_node($2, $1); };
          integer_prim: DT_LITERAL;
          %%

          static void yyerror(YYLTYPE *llocp, struct dt_info **dti, const char *s) {
              srcpos_error(llocp, "Error", "%s", s);
              treesource_error = true;
          }

          EOF

          # Creamos el nuevo y corregido dtc-lexer.l
          cat << 'EOF' > scripts/dtc/dtc-lexer.l
          %option yylineno noyywrap nounput noinput never-interactive

          %{
          #include <errno.h>
          #include <inttypes.h>
          #include "dtc.h"
          #include "srcpos.h"
          #include "dtc-parser.tab.h"

          #define YY_USER_ACTION  *llocp = *srcpos_copy(&yylloc);
          #define YY_INPUT(buf, result, max_size) (result = dtc_lexer_input(buf, max_size, yyscanner))

          #undef YY_DECL
          #define YY_DECL int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner)
          %}

          /* --- [El resto de las reglas del lexer, son estándar] --- */
          %%
          "/dts-v1/"              { return DT_V1; }
          "/plugin/"              { return DT_PLUGIN; }
          "/memreserve/"          { return DT_MEMRESERVE; }
          [a-zA-Z0-9,._+*#?@-]+   { yylval_param->propnodename = util_strdup(yytext); return DT_PROPNODENAME; }
          \"([^\\"]|\\.)*\"        { yylval_param->data = data_copy_escape_string(yytext+1, yyleng-2); return DT_STRING; }
          [0-9]+                  { yylval_param->integer = strtoull(yytext, NULL, 0); return DT_LITERAL; }
          [ \t\n]+                { /*
          
           IGNORE */ }
          .                       { return yytext[0]; }
          %%
          EOF

          echo "Files replaced successfully."
          
          
      # Paso 7: Configurar y Compilar
      - name: 7. Configure and Build the Kernel
        run: |
          sudo mv /usr/bin/ld /usr/bin/ld.bak
          # 2. Creamos un enlace simbólico que apunta a nuestro enlazador compatible
          sudo ln -s $GITHUB_WORKSPACE/clang-toolchain/clang-r416183b/bin/lld /usr/bin/ld
          echo "System linker has been replaced with ld.lld."
          
          cd kernel_source
          
          echo "Applying comprehensive patch to fix bison/flex pure_parser errors..."
          
          export PATH=$GITHUB_WORKSPACE/clang-toolchain/clang-r416183b/bin:$GITHUB_WORKSPACE/toolchain/linux-x86/bin:$GITHUB_WORKSPACE/kernel-toolchain/linux-x86/bin:$GITHUB_WORKSPACE/gcc-aarch64/bin:$PATH
          
          # CORRECCIÓN: Añadir CROSS_COMPILE y CC=clang para usar la toolchain correcta
          make ARCH=arm64 CROSS_COMPILE=aarch64-linux-android- CC=clang O=out defconfig
          
          make ARCH=arm64 CROSS_COMPILE=aarch64-linux-android- CC=clang O=out -j$(nproc --all)
          
          echo "Kernel build finished."
      # Paso 8: Subir los artefactos
      - name: 8. Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Unisoc-Kernel-Build
          path: |
            kernel_source/out/*
